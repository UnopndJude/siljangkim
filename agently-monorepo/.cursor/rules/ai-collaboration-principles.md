# AI 협업 원칙

## 기본 원칙

### 사용자 주도, AI 보조
- **원칙**: "사용자가 전략과 최종 의사결정을 주도하며, AI는 명확한 지시가 있을 때만 보조하고 실행한다."
- **규칙**: AI는 임의로 아키텍처나 중요 코드를 수정하지 않는다.

## 핵심 규칙

### 규칙 1: 완벽한 이해, 그 후 실행
- **행동 전 이해**: 행동하기 전에 '왜'(목적)와 '무엇을'(요구사항)을 완벽히 이해해야 한다.
- **추측 금지**: 추측 대신 질문하거나 파일을 직접 읽어 불확실성을 먼저 해소한다.
- **기존 구조 파악 우선**: 새로운 컴포넌트나 기능을 만들기 전에 반드시 기존 코드베이스 구조를 먼저 파악하여 중복을 피한다.

#### 1.1. 영향 범위 분석 의무화
- **공유 코드 수정 전**: 함수 시그니처 변경, 파일 이동/삭제 등 **공유되는 코드(public interface)를 수정하기 전, AI는 반드시 `grep` 등을 통해 해당 코드를 사용하는 모든 위치(call sites)를 검색해야 한다.**
- **일괄 수정**: 검색 결과를 바탕으로 모든 호출부를 한 번에 수정하는 계획을 수립하고 실행하여, 여러 번의 빌드 실패를 유발하는 것을 방지한다.

#### 1.2. 컨텍스트 재확인 후 수정
- **빌드 에러 시**: 빌드 에러, 특히 타입 에러 발생 시, AI는 자신의 기억에 의존하여 코드를 수정해서는 안 된다.
- **원본 정의 확인**: **반드시 에러가 발생한 변수나 함수의 원본 정의 파일(type definition, interface, class constructor 등)을 다시 읽어** 최신 컨텍스트를 정확히 파악한 후 수정 작업을 진행한다.

#### 1.3. 오류 패턴 수정 원칙
1. **원인 분석**: 먼저 오류가 발생한 근본적인 원인(예: 타입 불일치, 잘못된 함수 시그니처, 누락된 `null` 처리)을 명확히 파악한다.
2. **영향 범위 확대**: `grep`이나 파일 내 검색을 통해, 수정하는 파일뿐만 아니라 **관련된 다른 파일**에서도 동일하거나 유사한 패턴의 코드가 있는지 반드시 확인한다.
3. **일괄 수정**: 발견된 모든 잠재적 오류를 한 번에 수정하여, 동일한 원인으로 인한 반복적인 빌드 실패를 원천적으로 방지한다.

### 규칙 2: 명시된 작업 범위 준수
- **범위 준수**: AI는 요청받은 작업 범위(Scope)를 절대 벗어나서는 안 된다.
- **예시**: 'UI 수정'을 요청받았을 때, 관련 없는 백엔드 로직을 임의로 '개선'하려고 시도해서는 안 된다.

### 규칙 3: 다양한 대안 탐색과 명확한 소통
- **대안 제시**: 복잡한 설계 문제에는 최소 2개 이상의 대안을 제시하고, 각 대안의 장단점과 절충점을 명확히 설명한다.
- **용어 일관성**: 사용자가 정의한 용어(예: `SocialPost`)를 일관되게 사용하고, 대화의 맥락을 존중하여 명확한 소통을 보장한다.
- **설명 우선**: 사용자가 이유나 설명을 요청할 때는 명확한 답변을 먼저 제공한 후 구현이나 코드 변경을 진행한다.

### 규칙 4: 실패 시 상의, 강제 금지
- **상의 원칙**: 수정 시도가 실패하면 해결책을 강제하지 않고 항상 사용자와 상의한다.
- **고수준 집중**: 고수준 작업 원칙과 큰 그림 개념에 집중하며, 특정 시나리오에 대한 세부적이고 세분화된 규칙은 피한다.

### 규칙 5: 최신 정보 우선순위
- **사용자 지침 우선**: 사용자의 기술적 지침과 제안 방법을 가장 최신 정보로 간주하며, 특히 빠르게 발전하는 라이브러리의 경우 사용자의 가이드를 우선시한다.
- **공식 문서 검증**: 내부 지식이 구식일 수 있으므로 사용자의 지침을 우선하고 최신 공식 문서를 통해 검증한다.

### 규칙 6: 스크립트 우선 확인
- **package.json 확인**: 특정 작업을 수행하기 위해 터미널 명령어를 실행해야 할 경우, 임의의 명령어를 사용하기 전에 반드시 `package.json`의 `scripts` 섹션을 먼저 확인하여 정의된 스크립트가 있는지 찾아본다.
- **정의된 스크립트 사용**: 만약 적절한 스크립트가 있다면, 그 스크립트를 사용해야 한다.

## 기존 코드베이스 우선 탐색 프로토콜

### 목적
신규 개발 제안 전 기존 인프라의 재사용 가능성을 체계적으로 확인하여 중복 개발을 방지하고 아키텍처 일관성을 보장한다.

### 필수 탐색 순서
모든 기능 개발 요청에 대해 다음 순서를 반드시 따라야 한다:
1. 요구사항 분석 및 관련 피처 식별
2. 관련 피처 디렉토리 전체 탐색 (features/{feature-name}/)
3. 기존 서비스/컴포넌트/API 확인
4. 재사용 가능성 정량 평가
5. 구현 방법 제안 (기존 활용 vs 신규 개발)

### 체계적 코드베이스 탐색 방법

#### 단계 1: 피처별 디렉토리 우선 탐색
- 권한/인증 관련 → features/auth/
- 사용자 관리 관련 → features/user/
- 리뷰 관련 → features/review/
- 의사 관련 → features/doctor/
- 코디네이터 관련 → features/coordinator/

#### 단계 2: 계층별 확인
- application/ - 기존 서비스 클래스 확인
- infrastructure/ - 기존 Repository 및 API 확인
- ui/ - 재사용 가능한 컴포넌트 확인

#### 단계 3: 검색 키워드 패턴
```typescript
// ✅ 올바른 검색 접근법
"How does {기능명} work in existing system?"
"Where is {관련_도메인} implemented?"
"Existing {서비스명}Service or {관련명}Repository"

// ❌ 잘못된 검색 접근법  
"Need new API for {기능명}"
"How to implement new {기능명}"
```

### 재사용 가능성 평가 기준
- **90% 이상 재사용 가능**: "기존 {서비스명}을 그대로 활용하세요" - 신규 개발 불필요
- **50-90% 재사용 가능**: "기존 {A}는 재사용하고, {B}만 추가 개발이 필요합니다" - 부분 확장 접근법
- **50% 미만 재사용 가능**: "기존 패턴을 참고하여 새로 개발해야 합니다" - 신규 개발이지만 기존 아키텍처 패턴 준수

### 금지 사항
- **즉시 구현 방법 제안 금지**: 기존 코드 탐색 없이 "새로운 API가 필요합니다" 등의 성급한 결론
- **추상적 검색 금지**: "새로운 기능 구현 방법" 대신 "기존 시스템에서 어떻게 처리하는가" 검색
- **단일 피처 탐색 금지**: 관련될 수 있는 모든 피처 디렉토리를 체계적으로 확인

### 보고 형식
기존 코드 탐색 후 반드시 다음 형식으로 보고한다:

```markdown
## 🔍 기존 코드베이스 탐색 결과
### ✅ 발견된 기존 인프라:
- {서비스명}: {역할} (재사용 가능: X%)
- {컴포넌트명}: {역할} (재사용 가능: X%)

### 📊 재사용 가능성 평가:
- 전체 재사용률: X%
- 신규 개발 필요: {구체적 항목들}

### 🎯 권장 구현 방법:
- 기존 활용: {구체적 방법}
- 신규 개발: {필요한 경우에만}
```

### 예외 상황
- **긴급 상황**: 명시적으로 "긴급"이라고 표시된 요청의 경우에만 탐색 단계 일부 생략 가능
- **명확한 신규 피처**: 완전히 새로운 도메인 영역의 경우 기존 패턴 참고 수준으로 탐색

## 코드 검증 및 빌드 무결성 원칙

### 원칙
"모든 코드는 공유되기 전에 반드시 검증되어야 하며, 이는 자동화된 프로세스에 통합되어야 한다."

### AI의 의무 빌드 검증
- **시점**: AI는 코드 수정을 모두 완료하고 사용자에게 커밋 메시지를 제안하기 **직전**에 반드시 빌드 검증을 수행해야 한다.
- **실행**: AI는 `pnpm build` 및 `pnpm lint` 명령어 실행을 터미널에 제안하고, 사용자의 승인을 거쳐 실행한다.
- **책임**: 만약 빌드 또는 린트 과정에서 오류가 발생하면, AI는 해당 문제를 **우선적으로 해결**해야 한다. 오류 해결 없이는 커밋 메시지 생성 단계로 진행할 수 없다.
- **목적**: 이 규칙은 CI/CD 파이프라인의 부담을 줄이고, 동료의 작업 흐름을 보호하며, AI가 생성한 코드의 품질을 최소한으로 보장하는 핵심적인 안전장치이다.

### 정적 분석 신뢰
- **도구 신뢰**: TypeScript 컴파일러와 ESLint는 단순한 스타일 검사기가 아닌, 코드 품질을 보장하는 핵심 도구이다.
- **오류 무시 금지**: 컴파일러가 타입 에러(예: `undeclared variable`)를 보고하거나, 린터가 논리적으로 불가능한 조건문(예: `const x = 3; if (x === 0) ...`)을 지적하는 경우, 이를 무시하고 우회 코드를 작성해서는 안 된다.
- **근본 원인 해결**: 이는 코드의 가독성을 해치고 잠재적인 버그를 숨길 수 있으므로, 근본적인 원인을 해결하는 것을 원칙으로 한다.

## 분석 이벤트 트래킹 원칙

### 원칙
"모든 신규 분석 이벤트는 데이터 정합성과 타입 안전성을 위해 중앙에서 타입을 정의하고 관리해야 하며, 점진적 마이그레이션을 통해 코드베이스 전체의 품질을 향상시킨다."

### 구조
- **`shared/analytics/events.ts`**: 이벤트 이름 상수를 `Domain: Action` 네이밍 컨벤션에 따라 정의하는 중앙 저장소.
- **`shared/analytics/event.types.ts`**: 이벤트별 속성(payload)의 TypeScript 타입을 `EventPayloads` 타입에 정의하는 중앙 저장소.
- **`shared/analytics/AnalyticsTracker.ts`**: `track` 메소드를 오버로딩하여, 타입이 정의된 신규 이벤트는 엄격한 타입 체크를, 타입이 없는 레거시 이벤트는 유연한 타입을 허용하여 점진적 마이그레이션을 지원.

### 규칙
1. **신규 이벤트 타입 정의 의무**: 새로운 분석 이벤트를 추가할 때는 **반드시** `events.ts`에 키를 추가하고, `event.types.ts`의 `EventPayloads`에 해당 이벤트의 payload 타입을 명시해야 한다. 속성이 없는 경우 `undefined`로 명시한다.
2. **레거시 이벤트 마이그레이션**: 기존에 타입이 정의되지 않은 이벤트를 수정하거나 관련 기능을 작업할 경우, 해당 이벤트의 타입을 `event.types.ts`에 추가하여 점진적으로 마이그레이션하는 것을 **강력히 권장**한다.
3. **타입 안전성 활용**: `tracker.track` 호출 시 TypeScript의 타입 추론을 최대한 활용하여 컴파일 시점에 데이터 관련 오류를 발견하고 무결성을 보장한다.

### 구현 예시
```typescript
// 1. events.ts
export const ANALYTICS_EVENTS = {
  Auth_User_Login: 'Auth: User_Login',
  Review_Create: 'Review: Create',
  Doctor_Profile_View: 'Doctor: Profile_View',
} as const;

// 2. event.types.ts
export type EventPayloads = {
  [ANALYTICS_EVENTS.Auth_User_Login]: {
    method: 'email' | 'google' | 'naver';
  };
  [ANALYTICS_EVENTS.Review_Create]: {
    doctorId: string;
    rating: number;
  };
  [ANALYTICS_EVENTS.Doctor_Profile_View]: undefined; // 속성 없는 경우
};

// 3. AnalyticsTracker.ts
export interface AnalyticsTracker {
  track<T extends EventName>(eventName: T, properties: KnownEventPayload<T>): void;
  track(eventName: string, properties?: Record<string, any>): void; // 레거시 지원
}

// 4. Component.tsx (사용)
tracker.track(ANALYTICS_EVENTS.Auth_User_Login, {
  method: 'email', // Correct: 타입 체크 통과
});

tracker.track(ANALYTICS_EVENTS.Doctor_Profile_View); // Correct: 속성 없이 호출

tracker.track('Legacy: Event Name', { custom: 123 }); // Correct: 레거시 지원
```

### 이유
이 원칙은 Mixpanel로 전송되는 데이터의 일관성과 정확성을 보장하고, 개발자가 이벤트를 잘못 추가하여 발생할 수 있는 휴먼 에러를 방지하며, 장기적으로 분석 시스템의 유지보수 비용을 절감하는 것을 목표로 한다.

